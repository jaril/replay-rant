"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const sourcemap_upload_1 = require("@replayio/sourcemap-upload");
const commander_1 = require("commander");
const formatRecordings_1 = require("./cli/formatRecordings");
const main_1 = require("./main");
// TODO(dmiller): `--json` should probably be a global option that applies to all commands.
commander_1.program
    .command("ls")
    .description("List information about all recordings.")
    .option("--directory <dir>", "Alternate recording directory.")
    .option("-a, --all", "Include all recordings")
    .option("--json", "Output in JSON format")
    .option("--filter <filter string>", "String to filter recordings")
    .action(commandListAllRecordings);
commander_1.program
    .command("upload <id>")
    .description("Upload a recording to the remote server.")
    .option("--directory <dir>", "Alternate recording directory.")
    .option("--server <address>", "Alternate server to upload recordings to.")
    .option("--api-key <key>", "Authentication API Key")
    .action(commandUploadRecording);
commander_1.program
    .command("process <id>")
    .description("Upload a recording to the remote server and process it.")
    .option("--directory <dir>", "Alternate recording directory.")
    .option("--server <address>", "Alternate server to upload recordings to.")
    .option("--api-key <key>", "Authentication API Key")
    .action(commandProcessRecording);
commander_1.program
    .command("upload-all")
    .description("Upload all recordings to the remote server.")
    .option("--directory <dir>", "Alternate recording directory.")
    .option("--server <address>", "Alternate server to upload recordings to.")
    .option("--api-key <key>", "Authentication API Key")
    .option("--filter <filter string>", "String to filter recordings")
    .option("--batch-size <batchSize number>", "Number of recordings to upload in parallel (max 25)")
    .option("--include-in-progress", "Upload all recordings, including ones with an in progress status")
    .action(commandUploadAllRecordings);
commander_1.program
    .command("view <id>")
    .description("Load the devtools on a recording, uploading it if needed.")
    .option("--directory <dir>", "Alternate recording directory.")
    .option("--server <address>", "Alternate server to upload recordings to.")
    .option("--api-key <key>", "Authentication API Key")
    .action(commandViewRecording);
commander_1.program
    .command("view-latest")
    .description("Load the devtools on the latest recording, uploading it if needed.")
    .option("--directory <dir>", "Alternate recording directory.")
    .option("--server <address>", "Alternate server to upload recordings to.")
    .option("--api-key <key>", "Authentication API Key")
    .action(commandViewLatestRecording);
commander_1.program
    .command("rm <id>")
    .description("Remove a specific recording.")
    .option("--directory <dir>", "Alternate recording directory.")
    .action(commandRemoveRecording);
commander_1.program
    .command("rm-all")
    .description("Remove all recordings.")
    .option("--directory <dir>", "Alternate recording directory.")
    .action(commandRemoveAllRecordings);
commander_1.program
    .command("update-browsers")
    .description("Update browsers used in automation.")
    .option("--directory <dir>", "Alternate recording directory.")
    .action(commandUpdateBrowsers);
commander_1.program
    .command("upload-sourcemaps")
    .requiredOption("-g, --group <name>", "The name to group this sourcemap into, e.g. A commit SHA or release version.")
    .option("--api-key <key>", "Authentication API Key")
    .option("--dry-run", "Perform all of the usual CLI logic, but the final sourcemap upload.")
    .option("-x, --extensions <exts>", "A comma-separated list of extensions to process. Defaults to '.js,.map'.", collectExtensions)
    .option("-i, --ignore <pattern>", "Ignore files that match this pattern", collectIgnorePatterns)
    .option("-q, --quiet", "Silence all stdout logging.")
    .option("-v, --verbose", "Output extra data to stdout when processing files.")
    .option("--root <dirname>", "The base directory to use when computing relative paths")
    .option("--server <address>", "Alternate server to upload sourcemaps to.")
    .arguments("<paths...>")
    .action((filepaths, opts) => commandUploadSourcemaps(filepaths, opts));
commander_1.program
    .command("metadata")
    .option("--init [metadata]")
    .option("--keys <keys...>", "Metadata keys to initialize")
    .option("--warn", "Warn on initialization error")
    .option("--filter <filter string>", "String to filter recordings")
    .action(commandMetadata);
commander_1.program.parseAsync().catch(err => {
    console.log(err);
    process.exit(1);
});
function collectExtensions(value) {
    return value.split(",");
}
function collectIgnorePatterns(value, previous = []) {
    return previous.concat([value]);
}
function commandListAllRecordings(opts) {
    const recordings = (0, main_1.listAllRecordings)(Object.assign(Object.assign({}, opts), { verbose: true }));
    if (opts.json) {
        console.log((0, formatRecordings_1.formatAllRecordingsJson)(recordings));
    }
    else {
        console.log((0, formatRecordings_1.formatAllRecordingsHumanReadable)(recordings));
    }
    process.exit(0);
}
function commandUploadRecording(id, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const recordingId = yield (0, main_1.uploadRecording)(id, Object.assign(Object.assign({}, opts), { verbose: true }));
        process.exit(recordingId ? 0 : 1);
    });
}
function commandProcessRecording(id, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const recordingId = yield (0, main_1.processRecording)(id, Object.assign(Object.assign({}, opts), { verbose: true }));
        process.exit(recordingId ? 0 : 1);
    });
}
function commandUploadAllRecordings(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const uploadedAll = yield (0, main_1.uploadAllRecordings)(Object.assign(Object.assign({}, opts), { verbose: true }));
        process.exit(uploadedAll ? 0 : 1);
    });
}
function commandViewRecording(id, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const viewed = yield (0, main_1.viewRecording)(id, Object.assign(Object.assign({}, opts), { verbose: true }));
        process.exit(viewed ? 0 : 1);
    });
}
function commandViewLatestRecording(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const viewed = yield (0, main_1.viewLatestRecording)(Object.assign(Object.assign({}, opts), { verbose: true }));
        process.exit(viewed ? 0 : 1);
    });
}
function commandRemoveRecording(id, opts) {
    const removed = (0, main_1.removeRecording)(id, Object.assign(Object.assign({}, opts), { verbose: true }));
    process.exit(removed ? 0 : 1);
}
function commandRemoveAllRecordings(opts) {
    (0, main_1.removeAllRecordings)(Object.assign(Object.assign({}, opts), { verbose: true }));
    process.exit(0);
}
function commandUpdateBrowsers(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        yield (0, main_1.updateBrowsers)(Object.assign(Object.assign({}, opts), { verbose: true }));
        process.exit(0);
    });
}
function commandUploadSourcemaps(filepaths, cliOpts) {
    return __awaiter(this, void 0, void 0, function* () {
        const { quiet, verbose, apiKey } = cliOpts, uploadOpts = __rest(cliOpts, ["quiet", "verbose", "apiKey"]);
        let log;
        if (!quiet) {
            if (verbose) {
                log = (_level, message) => {
                    console.log(message);
                };
            }
            else {
                log = (level, message) => {
                    if (level === "normal") {
                        console.log(message);
                    }
                };
            }
        }
        yield (0, sourcemap_upload_1.uploadSourceMaps)(Object.assign(Object.assign({ filepaths, key: apiKey }, uploadOpts), { log }));
    });
}
function commandMetadata(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        yield (0, main_1.updateMetadata)(Object.assign(Object.assign({}, opts), { verbose: true }));
    });
}
//# sourceMappingURL=bin.js.map
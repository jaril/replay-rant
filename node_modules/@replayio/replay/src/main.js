"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPuppeteerBrowserPath = exports.getPlaywrightBrowserPath = exports.ensurePuppeteerBrowsersInstalled = exports.ensurePlaywrightBrowsersInstalled = exports.updateMetadata = exports.updateBrowsers = exports.removeAllRecordings = exports.removeRecording = exports.viewLatestRecording = exports.viewRecording = exports.uploadAllRecordings = exports.processRecording = exports.uploadRecording = exports.listAllRecordings = exports.addLocalRecordingMetadata = void 0;
const debug_1 = __importDefault(require("debug"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
// requiring v4 explicitly because it's the last version with commonjs support.
// Should be upgraded to the latest when converting this code to es modules.
const p_map_1 = __importDefault(require("p-map"));
const upload_1 = require("./upload");
const install_1 = require("./install");
Object.defineProperty(exports, "ensurePuppeteerBrowsersInstalled", { enumerable: true, get: function () { return install_1.ensurePuppeteerBrowsersInstalled; } });
Object.defineProperty(exports, "ensurePlaywrightBrowsersInstalled", { enumerable: true, get: function () { return install_1.ensurePlaywrightBrowsersInstalled; } });
Object.defineProperty(exports, "getPlaywrightBrowserPath", { enumerable: true, get: function () { return install_1.getPlaywrightBrowserPath; } });
Object.defineProperty(exports, "getPuppeteerBrowserPath", { enumerable: true, get: function () { return install_1.getPuppeteerBrowserPath; } });
Object.defineProperty(exports, "updateBrowsers", { enumerable: true, get: function () { return install_1.updateBrowsers; } });
const utils_1 = require("./utils");
const child_process_1 = require("child_process");
const metadata_1 = require("../metadata");
const generateDefaultTitle_1 = require("./generateDefaultTitle");
const jsonata_1 = __importDefault(require("jsonata"));
const debug = (0, debug_1.default)("replay:cli");
function getRecordingsFile(dir) {
    return path_1.default.join(dir, "recordings.log");
}
function readRecordingFile(dir) {
    const file = getRecordingsFile(dir);
    if (!fs_1.default.existsSync(file)) {
        return [];
    }
    return fs_1.default.readFileSync(file, "utf8").split("\n");
}
function writeRecordingFile(dir, lines) {
    // Add a trailing newline so the driver can safely append logs
    fs_1.default.writeFileSync(getRecordingsFile(dir), lines.join("\n") + "\n");
}
function getBuildRuntime(buildId) {
    const match = /.*?-(.*?)-/.exec(buildId);
    return match ? match[1] : "unknown";
}
function readRecordings(dir, includeHidden = false) {
    const recordings = [];
    const lines = readRecordingFile(dir);
    for (const line of lines) {
        let obj;
        try {
            obj = JSON.parse(line);
        }
        catch (e) {
            // Ignore lines that aren't valid JSON.
            continue;
        }
        switch (obj.kind) {
            case "createRecording": {
                const { id, timestamp, buildId } = obj;
                recordings.push({
                    id,
                    createTime: new Date(timestamp),
                    buildId,
                    runtime: getBuildRuntime(buildId),
                    metadata: {},
                    sourcemaps: [],
                    // We use an unknown status after the createRecording event because
                    // there should always be later events describing what happened to the
                    // recording.
                    status: "unknown",
                });
                break;
            }
            case "addMetadata": {
                const { id, metadata } = obj;
                const recording = recordings.find(r => r.id == id);
                if (recording) {
                    Object.assign(recording.metadata, metadata);
                    if (!recording.metadata.title) {
                        recording.metadata.title = (0, generateDefaultTitle_1.generateDefaultTitle)(recording.metadata);
                    }
                }
                break;
            }
            case "writeStarted": {
                const { id, path } = obj;
                const recording = recordings.find(r => r.id == id);
                if (recording) {
                    updateStatus(recording, "startedWrite");
                    recording.path = path;
                }
                break;
            }
            case "writeFinished": {
                const { id } = obj;
                const recording = recordings.find(r => r.id == id);
                if (recording) {
                    updateStatus(recording, "onDisk");
                }
                break;
            }
            case "uploadStarted": {
                const { id, server, recordingId } = obj;
                const recording = recordings.find(r => r.id == id);
                if (recording) {
                    updateStatus(recording, "startedUpload");
                    recording.server = server;
                    recording.recordingId = recordingId;
                }
                break;
            }
            case "uploadFinished": {
                const { id } = obj;
                const recording = recordings.find(r => r.id == id);
                if (recording) {
                    updateStatus(recording, "uploaded");
                }
                break;
            }
            case "recordingUnusable": {
                const { id, reason } = obj;
                const recording = recordings.find(r => r.id == id);
                if (recording) {
                    updateStatus(recording, "unusable");
                    recording.unusableReason = reason;
                }
                break;
            }
            case "crashed": {
                const { id } = obj;
                const recording = recordings.find(r => r.id == id);
                if (recording) {
                    updateStatus(recording, "crashed");
                }
                break;
            }
            case "crashData": {
                const { id, data } = obj;
                const recording = recordings.find(r => r.id == id);
                if (recording) {
                    if (!recording.crashData) {
                        recording.crashData = [];
                    }
                    recording.crashData.push(data);
                }
                break;
            }
            case "crashUploaded": {
                const { id } = obj;
                const recording = recordings.find(r => r.id == id);
                if (recording) {
                    updateStatus(recording, "crashUploaded");
                }
                break;
            }
            case "sourcemapAdded": {
                const { id, recordingId, path, baseURL, targetContentHash, targetURLHash, targetMapURLHash, } = obj;
                const recording = recordings.find(r => r.id == recordingId);
                if (recording) {
                    recording.sourcemaps.push({
                        id,
                        path,
                        baseURL,
                        targetContentHash,
                        targetURLHash,
                        targetMapURLHash,
                        originalSources: [],
                    });
                }
                break;
            }
            case "originalSourceAdded": {
                const { recordingId, path, parentId, parentOffset } = obj;
                const recording = recordings.find(r => r.id === recordingId);
                if (recording) {
                    const sourcemap = recording.sourcemaps.find(s => s.id === parentId);
                    if (sourcemap) {
                        sourcemap.originalSources.push({
                            path,
                            parentOffset,
                        });
                    }
                }
                break;
            }
        }
    }
    if (includeHidden) {
        return recordings;
    }
    // There can be a fair number of recordings from gecko/chromium content
    // processes which never loaded any interesting content. These are ignored by
    // most callers. Note that we're unable to avoid generating these entries in
    // the first place because the recordings log is append-only and we don't know
    // when a recording process starts if it will ever do anything interesting.
    return recordings.filter(r => !(r.unusableReason || "").includes("No interesting content"));
}
function updateStatus(recording, status) {
    // Once a recording enters an unusable or crashed status, don't change it
    // except to mark crashes as uploaded.
    if (recording.status == "unusable" ||
        recording.status == "crashUploaded" ||
        (recording.status == "crashed" && status != "crashUploaded")) {
        return;
    }
    recording.status = status;
}
function filterRecordings(recordings, filter) {
    debug("Recording log contains %d replays", recordings.length);
    if (filter) {
        debug("Using filter: %s", filter);
        const exp = (0, jsonata_1.default)(`$filter($, ${filter})[]`);
        recordings = exp.evaluate(recordings) || [];
        debug("Filtering resulted in %d replays", recordings.length);
    }
    return recordings;
}
// Convert a recording into a format for listing.
function listRecording(recording) {
    // Remove properties we only use internally.
    const { buildId, crashData } = recording, recordingWithoutInternalProperties = __rest(recording, ["buildId", "crashData"]);
    return recordingWithoutInternalProperties;
}
function listAllRecordings(opts = {}) {
    const dir = (0, utils_1.getDirectory)(opts);
    const recordings = readRecordings(dir);
    if (opts.all) {
        return filterRecordings(recordings, opts.filter).map(listRecording);
    }
    const uploadableRecordings = recordings.filter(recording => ["onDisk", "startedWrite", "crashed"].includes(recording.status));
    return filterRecordings(uploadableRecordings, opts.filter).map(listRecording);
}
exports.listAllRecordings = listAllRecordings;
function uploadSkipReason(recording) {
    // Status values where there is something worth uploading.
    const canUploadStatus = ["onDisk", "startedWrite", "startedUpload", "crashed"];
    if (!canUploadStatus.includes(recording.status)) {
        return `wrong recording status ${recording.status}`;
    }
    if (!recording.path && recording.status != "crashed") {
        return "recording not saved to disk";
    }
    return null;
}
function getServer(opts) {
    return opts.server || process.env.RECORD_REPLAY_SERVER || "wss://dispatch.replay.io";
}
function addRecordingEvent(dir, kind, id, tags = {}) {
    const event = Object.assign({ kind,
        id, timestamp: Date.now() }, tags);
    debug("Writing event to recording log %o", event);
    const lines = readRecordingFile(dir);
    lines.push(JSON.stringify(event));
    writeRecordingFile(dir, lines);
}
function doUploadCrash(dir, server, recording, verbose, apiKey, agent) {
    return __awaiter(this, void 0, void 0, function* () {
        const client = new upload_1.ReplayClient();
        (0, utils_1.maybeLog)(verbose, `Starting crash data upload for ${recording.id}...`);
        if (!(yield client.initConnection(server, apiKey, verbose, agent))) {
            (0, utils_1.maybeLog)(verbose, `Crash data upload failed: can't connect to server ${server}`);
            return null;
        }
        const crashData = recording.crashData || [];
        crashData.push({
            kind: "recordingMetadata",
            recordingId: recording.id,
        });
        yield Promise.all(crashData.map((data) => __awaiter(this, void 0, void 0, function* () {
            yield client.connectionReportCrash(data);
        })));
        addRecordingEvent(dir, "crashUploaded", recording.id, { server });
        (0, utils_1.maybeLog)(verbose, `Crash data upload finished.`);
        client.closeConnection();
    });
}
function doUploadRecording(dir, server, recording, verbose, apiKey, agent) {
    return __awaiter(this, void 0, void 0, function* () {
        debug("Uploading %s from %s to %s", recording.id, dir, server);
        (0, utils_1.maybeLog)(verbose, `Starting upload for ${recording.id}...`);
        if (recording.status == "uploaded" && recording.recordingId) {
            (0, utils_1.maybeLog)(verbose, `Already uploaded: ${recording.recordingId}`);
            return recording.recordingId;
        }
        const reason = uploadSkipReason(recording);
        if (reason) {
            (0, utils_1.maybeLog)(verbose, `Upload failed: ${reason}`);
            return null;
        }
        if (recording.status == "crashed") {
            debug("Uploading crash %o", recording);
            yield doUploadCrash(dir, server, recording, verbose, apiKey, agent);
            (0, utils_1.maybeLog)(verbose, `Crash uploaded: crashed while recording`);
            (0, utils_1.maybeLog)(verbose, `Recording upload failed: crashed while recording`);
            return recording.id;
        }
        debug("Uploading recording %o", recording);
        const client = new upload_1.ReplayClient();
        if (!(yield client.initConnection(server, apiKey, verbose, agent))) {
            (0, utils_1.maybeLog)(verbose, `Upload failed: can't connect to server ${server}`);
            return null;
        }
        // validate metadata before uploading so invalid data can block the upload
        const metadata = recording.metadata
            ? yield client.buildRecordingMetadata(recording.metadata, { verbose })
            : null;
        const recordingId = yield client.connectionCreateRecording(recording.id, recording.buildId);
        debug(`Created remote recording ${recordingId}`);
        if (metadata) {
            try {
                yield client.setRecordingMetadata(recordingId, metadata);
            }
            catch (e) {
                console.warn("Failed to set recording metadata");
                console.warn(e);
            }
        }
        addRecordingEvent(dir, "uploadStarted", recording.id, {
            server,
            recordingId,
        });
        yield client.connectionUploadRecording(recordingId, recording.path);
        for (const sourcemap of recording.sourcemaps) {
            try {
                const contents = fs_1.default.readFileSync(sourcemap.path, "utf8");
                const sourcemapId = yield client.connectionUploadSourcemap(recordingId, sourcemap, contents);
                for (const originalSource of sourcemap.originalSources) {
                    const contents = fs_1.default.readFileSync(originalSource.path, "utf8");
                    yield client.connectionUploadOriginalSource(recordingId, sourcemapId, originalSource, contents);
                }
            }
            catch (e) {
                (0, utils_1.maybeLog)(verbose, `can't upload sourcemap from disk: ${e}`);
            }
        }
        addRecordingEvent(dir, "uploadFinished", recording.id);
        (0, utils_1.maybeLog)(verbose, `Upload finished! View your Replay at: https://app.replay.io/recording/${recordingId}`);
        client.closeConnection();
        return recordingId;
    });
}
function uploadRecording(id, opts = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const server = getServer(opts);
        const dir = (0, utils_1.getDirectory)(opts);
        const recordings = readRecordings(dir);
        const recording = recordings.find(r => r.id == id);
        if (!recording) {
            (0, utils_1.maybeLog)(opts.verbose, `Unknown recording ${id}`);
            return null;
        }
        return doUploadRecording(dir, server, recording, opts.verbose, opts.apiKey, opts.agent);
    });
}
exports.uploadRecording = uploadRecording;
function processUploadedRecording(recordingId, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const server = getServer(opts);
        const { apiKey, verbose, agent } = opts;
        (0, utils_1.maybeLog)(verbose, `Processing recording ${recordingId}...`);
        const client = new upload_1.ReplayClient();
        if (!(yield client.initConnection(server, apiKey, verbose, agent))) {
            (0, utils_1.maybeLog)(verbose, `Processing failed: can't connect to server ${server}`);
            return false;
        }
        try {
            const error = yield client.connectionWaitForProcessed(recordingId);
            if (error) {
                (0, utils_1.maybeLog)(verbose, `Processing failed: ${error}`);
                return false;
            }
        }
        finally {
            client.closeConnection();
        }
        (0, utils_1.maybeLog)(verbose, "Finished processing.");
        return true;
    });
}
function processRecording(id, opts = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const recordingId = yield uploadRecording(id, opts);
        if (!recordingId) {
            return null;
        }
        const succeeded = yield processUploadedRecording(recordingId, opts);
        return succeeded ? recordingId : null;
    });
}
exports.processRecording = processRecording;
function uploadAllRecordings(opts = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const server = getServer(opts);
        const dir = (0, utils_1.getDirectory)(opts);
        const allRecordings = readRecordings(dir).filter(r => !uploadSkipReason(r));
        const recordings = filterRecordings(allRecordings, opts.filter);
        if (recordings.length === 0) {
            if (opts.filter && allRecordings.length > 0) {
                (0, utils_1.maybeLog)(opts.verbose, `No replays matched the provided filter`);
            }
            else {
                (0, utils_1.maybeLog)(opts.verbose, `No replays were found to upload`);
            }
            return;
        }
        (0, utils_1.maybeLog)(opts.verbose, `Starting upload of ${recordings.length} replays`);
        if (opts.batchSize) {
            debug("Batching upload in groups of %d", opts.batchSize);
        }
        const batchSize = Math.min(opts.batchSize || 20, 25);
        const recordingIds = yield (0, p_map_1.default)(recordings, (r) => doUploadRecording(dir, server, r, opts.verbose, opts.apiKey, opts.agent), { concurrency: batchSize, stopOnError: false });
        return recordingIds.every(r => r !== null);
    });
}
exports.uploadAllRecordings = uploadAllRecordings;
// Get the executable name to use when opening a URL.
// It would be nice to use an existing npm package for this,
// but the obvious choice of "open" didn't actually work on linux
// when testing...
function openExecutable() {
    switch (process.platform) {
        case "darwin":
            return "open";
        case "linux":
            return "xdg-open";
        default:
            throw new Error("Unsupported platform");
    }
}
function doViewRecording(dir, server, recording, verbose, apiKey, agent) {
    return __awaiter(this, void 0, void 0, function* () {
        let recordingId;
        if (recording.status == "uploaded") {
            recordingId = recording.recordingId;
            server = recording.server;
        }
        else {
            recordingId = yield doUploadRecording(dir, server, recording, verbose, apiKey, agent);
            if (!recordingId) {
                return false;
            }
        }
        const dispatch = server != "wss://dispatch.replay.io" ? `&dispatch=${server}` : "";
        (0, child_process_1.spawn)(openExecutable(), [`https://app.replay.io?id=${recordingId}${dispatch}`]);
        return true;
    });
}
function viewRecording(id, opts = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        let server = getServer(opts);
        const dir = (0, utils_1.getDirectory)(opts);
        const recordings = readRecordings(dir);
        const recording = recordings.find(r => r.id == id);
        if (!recording) {
            (0, utils_1.maybeLog)(opts.verbose, `Unknown recording ${id}`);
            return false;
        }
        return doViewRecording(dir, server, recording, opts.verbose, opts.apiKey, opts.agent);
    });
}
exports.viewRecording = viewRecording;
function viewLatestRecording(opts = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        let server = getServer(opts);
        const dir = (0, utils_1.getDirectory)(opts);
        const recordings = readRecordings(dir);
        if (!recordings.length) {
            (0, utils_1.maybeLog)(opts.verbose, "No recordings to view");
            return false;
        }
        return doViewRecording(dir, server, recordings[recordings.length - 1], opts.verbose, opts.apiKey, opts.agent);
    });
}
exports.viewLatestRecording = viewLatestRecording;
function maybeRemoveRecordingFile(recording) {
    if (recording.path) {
        try {
            fs_1.default.unlinkSync(recording.path);
        }
        catch (e) { }
    }
}
function removeRecording(id, opts = {}) {
    const dir = (0, utils_1.getDirectory)(opts);
    const recordings = readRecordings(dir);
    const recording = recordings.find(r => r.id == id);
    if (!recording) {
        (0, utils_1.maybeLog)(opts.verbose, `Unknown recording ${id}`);
        return false;
    }
    maybeRemoveRecordingFile(recording);
    const lines = readRecordingFile(dir).filter(line => {
        try {
            const obj = JSON.parse(line);
            if (obj.id == id) {
                return false;
            }
        }
        catch (e) {
            return false;
        }
        return true;
    });
    writeRecordingFile(dir, lines);
    return true;
}
exports.removeRecording = removeRecording;
function removeAllRecordings(opts = {}) {
    const dir = (0, utils_1.getDirectory)(opts);
    const recordings = readRecordings(dir);
    recordings.forEach(maybeRemoveRecordingFile);
    const file = getRecordingsFile(dir);
    if (fs_1.default.existsSync(file)) {
        fs_1.default.unlinkSync(file);
    }
}
exports.removeAllRecordings = removeAllRecordings;
function addLocalRecordingMetadata(recordingId, metadata) {
    (0, metadata_1.add)(recordingId, metadata);
}
exports.addLocalRecordingMetadata = addLocalRecordingMetadata;
function updateMetadata({ init: metadata, keys = [], filter, verbose, warn, }) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            let md = {};
            if (metadata) {
                md = JSON.parse(metadata);
            }
            const keyedObjects = yield (0, p_map_1.default)(keys, (v) => __awaiter(this, void 0, void 0, function* () {
                try {
                    switch (v) {
                        case "source":
                            return yield metadata_1.source.init(md.source || {});
                        case "test":
                            return yield metadata_1.test.init(md.test || {});
                    }
                }
                catch (e) {
                    if (!warn) {
                        console.error("Unable to initialize metadata field", v);
                        console.error(e);
                        process.exit(1);
                    }
                    console.warn("Unable to initialize metadata field", v);
                    console.warn(String(e));
                }
                return null;
            }));
            const data = Object.assign(md, ...keyedObjects);
            const sanitized = yield (0, metadata_1.sanitize)(data);
            (0, utils_1.maybeLog)(verbose, "Metadata:");
            (0, utils_1.maybeLog)(verbose, JSON.stringify(sanitized, undefined, 2));
            const recordings = filterRecordings(listAllRecordings(), filter);
            recordings.forEach(r => {
                (0, utils_1.maybeLog)(verbose, `Setting metadata for ${r.id}`);
                (0, metadata_1.add)(r.id, sanitized);
            });
        }
        catch (e) {
            console.error("Failed to set recording metadata");
            console.error(e);
            process.exit(1);
        }
    });
}
exports.updateMetadata = updateMetadata;
//# sourceMappingURL=main.js.map
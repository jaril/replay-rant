"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReplayClient = void 0;
const fs_1 = __importDefault(require("fs"));
const crypto_1 = __importDefault(require("crypto"));
const debug_1 = __importDefault(require("debug"));
const client_1 = __importDefault(require("./client"));
const utils_1 = require("./utils");
const metadata_1 = require("../metadata");
const debug = (0, debug_1.default)("replay:cli:upload");
// Granularity for splitting up a recording into chunks for uploading.
const ChunkGranularity = 1024 * 1024;
function sha256(text) {
    return crypto_1.default.createHash("sha256").update(text).digest("hex");
}
class ReplayClient {
    constructor() {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "clientReady", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (0, utils_1.defer)()
        });
    }
    initConnection(server, accessToken, verbose, agent) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client) {
                let { resolve } = this.clientReady;
                this.client = new client_1.default(server, {
                    onOpen: () => __awaiter(this, void 0, void 0, function* () {
                        try {
                            yield this.client.setAccessToken(accessToken);
                            resolve(true);
                        }
                        catch (err) {
                            (0, utils_1.maybeLog)(verbose, `Error authenticating with server: ${err}`);
                            resolve(false);
                        }
                    }),
                    onClose() {
                        resolve(false);
                    },
                    onError(e) {
                        (0, utils_1.maybeLog)(verbose, `Error connecting to server: ${e}`);
                        resolve(false);
                    },
                }, {
                    agent,
                });
            }
            return this.clientReady.promise;
        });
    }
    connectionCreateRecording(id, buildId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client)
                throw new Error("Protocol client is not initialized");
            const { recordingId } = yield this.client.sendCommand("Internal.createRecording", {
                buildId,
                // 3/22/2022: Older builds use integers instead of UUIDs for the recording
                // IDs written to disk. These are not valid to use as recording IDs when
                // uploading recordings to the backend.
                recordingId: (0, utils_1.isValidUUID)(id) ? id : undefined,
                // Ensure that if the upload fails, we will not create
                // partial recordings.
                requireFinish: true,
            });
            return recordingId;
        });
    }
    buildRecordingMetadata(metadata, opts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            // extract the "standard" metadata and route the `rest` through the sanitizer
            const { duration, url, uri, title, operations } = metadata, rest = __rest(metadata, ["duration", "url", "uri", "title", "operations"]);
            const metadataUrl = url || uri;
            return {
                recordingData: {
                    duration: typeof duration === "number" ? duration : 0,
                    url: typeof metadataUrl === "string" ? metadataUrl : "",
                    title: typeof title === "string" ? title : "",
                    operations: operations && typeof operations === "object"
                        ? operations
                        : {
                            scriptDomains: [],
                        },
                    lastScreenData: "",
                    lastScreenMimeType: "",
                },
                metadata: yield (0, metadata_1.sanitize)(rest),
            };
        });
    }
    setRecordingMetadata(id, metadata) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client)
                throw new Error("Protocol client is not initialized");
            metadata.recordingData.id = id;
            yield this.client.sendCommand("Internal.setRecordingMetadata", metadata);
        });
    }
    connectionProcessRecording(recordingId) {
        if (!this.client)
            throw new Error("Protocol client is not initialized");
        this.client.sendCommand("Recording.processRecording", { recordingId });
    }
    connectionWaitForProcessed(recordingId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client)
                throw new Error("Protocol client is not initialized");
            const { sessionId } = yield this.client.sendCommand("Recording.createSession", {
                recordingId,
            });
            const waiter = (0, utils_1.defer)();
            this.client.setEventListener("Recording.sessionError", ({ message }) => waiter.resolve(`session error ${sessionId}: ${message}`));
            this.client.setEventListener("Session.unprocessedRegions", () => { });
            this.client
                .sendCommand("Session.ensureProcessed", { level: "basic" }, null, sessionId)
                .then(() => waiter.resolve(null));
            const error = yield waiter.promise;
            return error;
        });
    }
    connectionReportCrash(data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client)
                throw new Error("Protocol client is not initialized");
            yield this.client.sendCommand("Internal.reportCrash", { data });
        });
    }
    connectionUploadRecording(recordingId, path) {
        var e_1, _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client)
                throw new Error("Protocol client is not initialized");
            const file = fs_1.default.createReadStream(path);
            let buffer;
            let offset = 0;
            debug("%s: Replay file size: %d bytes", recordingId, fs_1.default.statSync(path).size);
            const send = (b) => __awaiter(this, void 0, void 0, function* () {
                const length = b.length;
                debug("%s: Sending %d bytes at offset %d", recordingId, length, offset);
                yield new Promise((resolve, reject) => {
                    var _a;
                    return (_a = this.client) === null || _a === void 0 ? void 0 : _a.sendCommand("Internal.addRecordingData", { recordingId, offset, length }, b, undefined, err => (err ? reject(err) : resolve()));
                });
                offset += length;
            });
            try {
                for (var file_1 = __asyncValues(file), file_1_1; file_1_1 = yield file_1.next(), !file_1_1.done;) {
                    const chunk = file_1_1.value;
                    const cb = chunk instanceof Buffer ? chunk : Buffer.from(chunk);
                    debug("%s: Read %d bytes from file", recordingId, cb.length);
                    buffer = buffer ? Buffer.concat([buffer, cb]) : cb;
                    if (buffer.length >= ChunkGranularity) {
                        const data = buffer.subarray(0, ChunkGranularity);
                        buffer = buffer.subarray(ChunkGranularity);
                        yield send(data);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (file_1_1 && !file_1_1.done && (_a = file_1.return)) yield _a.call(file_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (buffer === null || buffer === void 0 ? void 0 : buffer.length) {
                yield send(buffer);
            }
            debug("%s: Uploaded %d bytes", recordingId, offset);
            // Explicitly mark the recording complete so the server knows that it has
            // been sent all of the recording data, and can save the recording.
            // This means if someone presses Ctrl+C, the server doesn't save a
            // partial recording.
            yield this.client.sendCommand("Internal.finishRecording", { recordingId });
        });
    }
    connectionUploadSourcemap(recordingId, metadata, content) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client)
                throw new Error("Protocol client is not initialized");
            const resource = yield this.createResource(content);
            const { baseURL, targetContentHash, targetURLHash, targetMapURLHash } = metadata;
            const result = yield this.client.sendCommand("Recording.addSourceMap", {
                recordingId,
                resource,
                baseURL,
                targetContentHash,
                targetURLHash,
                targetMapURLHash,
            });
            return result.id;
        });
    }
    connectionUploadOriginalSource(recordingId, parentId, metadata, content) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client)
                throw new Error("Protocol client is not initialized");
            const resource = yield this.createResource(content);
            const { parentOffset } = metadata;
            yield this.client.sendCommand("Recording.addOriginalSource", {
                recordingId,
                resource,
                parentId,
                parentOffset,
            });
        });
    }
    createResource(content) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client)
                throw new Error("Protocol client is not initialized");
            const hash = "sha256:" + sha256(content);
            const { token } = yield this.client.sendCommand("Resource.token", { hash });
            let resource = {
                token,
                saltedHash: "sha256:" + sha256(token + content),
            };
            const { exists } = yield this.client.sendCommand("Resource.exists", {
                resource,
            });
            if (!exists) {
                ({ resource } = yield this.client.sendCommand("Resource.create", { content }));
            }
            return resource;
        });
    }
    closeConnection() {
        if (this.client) {
            this.client.close();
            this.client = undefined;
            this.clientReady = (0, utils_1.defer)();
        }
    }
}
exports.ReplayClient = ReplayClient;
//# sourceMappingURL=upload.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMetadataFilePath = void 0;
/// <reference types="cypress" />
const test_utils_1 = require("@replayio/test-utils");
const fixture_1 = require("./fixture");
const mode_1 = require("./mode");
const steps_1 = require("./steps");
class CypressReporter {
    constructor(config, debug) {
        Object.defineProperty(this, "reporter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "config", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "debug", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "startTime", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "steps", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "selectedBrowser", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "errors", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "diagnosticConfig", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        (0, fixture_1.initFixtureFile)();
        this.config = config;
        this.reporter = new test_utils_1.ReplayReporter({
            name: "cypress",
            version: config.version,
            plugin: require("../package.json").version,
        });
        this.debug = debug.extend("reporter");
        this.diagnosticConfig = (0, mode_1.getDiagnosticConfig)(config);
        // Mix diagnostic env into process env so it can be picked up by test
        // metrics and reported to telemetry
        Object.keys(this.diagnosticConfig.env).forEach(k => {
            process.env[k] = this.diagnosticConfig.env[k];
        });
        this.reporter.setDiagnosticMetadata(this.diagnosticConfig.env);
    }
    onLaunchBrowser(browser) {
        this.setSelectedBrowser(browser);
        this.reporter.onTestSuiteBegin(undefined, "CYPRESS_REPLAY_METADATA");
        // Cypress around 10.9 launches the browser before `before:spec` is called
        // causing us to fail to create the metadata file and link the replay to the
        // current test
        const metadataPath = getMetadataFilePath();
        this.reporter.onTestBegin(undefined, metadataPath);
    }
    onBeforeSpec(spec) {
        const startTime = Date.now();
        (0, fixture_1.appendToFixtureFile)("spec:start", { spec, startTime });
        this.clearSteps();
        this.setStartTime(startTime);
        this.reporter.onTestBegin(undefined, getMetadataFilePath());
    }
    onAfterSpec(spec, result) {
        (0, fixture_1.appendToFixtureFile)("spec:end", { spec, result });
        const tests = this.getTestResults(spec, result);
        this.reporter.onTestEnd(tests, spec.relative);
    }
    getDiagnosticConfig() {
        return this.diagnosticConfig;
    }
    setStartTime(startTime) {
        this.startTime = startTime;
    }
    setSelectedBrowser(browser) {
        this.selectedBrowser = browser;
    }
    clearSteps() {
        this.steps = [];
    }
    addStep(step) {
        (0, fixture_1.appendToFixtureFile)("task", step);
        this.steps.push(step);
    }
    getTestResults(spec, result) {
        if (
        // If the browser crashes, no tests are run and tests will be null
        !result.tests ||
            // If the spec doesn't have any tests, we should bail
            result.tests.length === 0) {
            const msg = "No test results found for spec " + spec.relative;
            this.debug(msg);
            this.reporter.addError(new test_utils_1.ReporterError(spec.relative, msg));
            return [
                // return an placeholder test because cypress will still launch a
                // browser for a file that matches the spec format but doesn't contain
                // any tests.
                {
                    title: spec.relative,
                    path: [spec.relative],
                    result: "unknown",
                    relativePath: spec.relative,
                },
            ];
        }
        let testsWithSteps = [];
        try {
            testsWithSteps = (0, steps_1.groupStepsByTest)(spec, result.tests, this.steps, this.startTime, this.debug);
        }
        catch (e) {
            console.warn("Failed to build test step metadata for this replay.");
            console.warn(e);
            this.reporter.addError(e);
        }
        const tests = result.tests.map(t => {
            const foundTest = testsWithSteps.find(ts => ts.title === t.title[t.title.length - 1]);
            if (foundTest) {
                this.debug("Matching test result with test steps from support: %o", {
                    testResult: t.title,
                    testWithSteps: foundTest.path,
                });
            }
            else {
                this.debug("Failed to find matching test steps for test result: %o", {
                    testResult: t.title,
                });
            }
            const error = t.displayError
                ? {
                    // typically, we won't use this because we'll have a step error that
                    // originated the message but keeping as a fallback
                    message: t.displayError.substring(0, t.displayError.indexOf("\n")),
                }
                : undefined;
            return Object.assign(Object.assign({ title: t.title[t.title.length - 1] || spec.relative }, foundTest), { relativePath: spec.relative, path: ["", this.selectedBrowser || "", spec.relative, ...((foundTest === null || foundTest === void 0 ? void 0 : foundTest.path) || [])], result: (0, steps_1.mapStateToResult)(t.state), error });
        });
        return tests;
    }
}
function getMetadataFilePath(workerIndex = 0) {
    return (0, test_utils_1.getMetadataFilePath)("CYPRESS", workerIndex);
}
exports.getMetadataFilePath = getMetadataFilePath;
exports.default = CypressReporter;
//# sourceMappingURL=reporter.js.map
"use strict";
/// <reference types="cypress" />
Object.defineProperty(exports, "__esModule", { value: true });
exports.groupStepsByTest = exports.mapStateToResult = void 0;
const test_utils_1 = require("@replayio/test-utils");
const constants_1 = require("./constants");
function mapStateToResult(state) {
    switch (state) {
        case "failed":
        case "passed":
            return state;
        case "pending":
            return "skipped";
    }
    return "unknown";
}
exports.mapStateToResult = mapStateToResult;
function toTime(timestamp) {
    return new Date(timestamp).getTime();
}
function toRelativeTime(timestamp, startTime) {
    return toTime(timestamp) - startTime;
}
function toEventOrder(event) {
    return ["test:start", "step:enqueue", "step:start", "step:end", "test:end"].indexOf(event.event);
}
function assertCurrentTest(currentTest, step) {
    if (!currentTest) {
        throw new test_utils_1.ReporterError(step.test.join(" > "), "currentTest does not exist");
    }
}
function assertMatchingStep(currentStep, previousStep) {
    if (!currentStep ||
        !previousStep ||
        !currentStep.command ||
        !previousStep.command ||
        currentStep.command.id !== previousStep.command.id) {
        throw new test_utils_1.ReporterError(currentStep === null || currentStep === void 0 ? void 0 : currentStep.test.join(" > "), "Mismatched step event: " + JSON.stringify(currentStep) + JSON.stringify(previousStep));
    }
}
function shouldSkipStep(step, skippedSteps, debug) {
    var _a, _b, _c, _d, _e;
    debug = debug.extend("skip");
    const lastArg = (_b = (_a = step.command) === null || _a === void 0 ? void 0 : _a.args) === null || _b === void 0 ? void 0 : _b[step.command.args.length - 1];
    let reason;
    if (lastArg != null && typeof lastArg === "object" && lastArg.log === false) {
        reason = "Command logging disabled";
    }
    else if (skippedSteps.includes((_c = step.command) === null || _c === void 0 ? void 0 : _c.id)) {
        reason = "Prior step event already skipped";
    }
    else if (skippedSteps.includes((_d = step.command) === null || _d === void 0 ? void 0 : _d.groupId)) {
        reason = "Parent skipped";
    }
    if (reason) {
        debug("Test step %s skipped: %s", ((_e = step.command) === null || _e === void 0 ? void 0 : _e.id) || "", reason);
        return true;
    }
    return false;
}
function groupStepsByTest(spec, resultTests, steps, firstTimestamp, debug) {
    var _a, _b, _c, _d, _e, _f, _g;
    debug = debug.extend("group");
    if (steps.length === 0) {
        debug("No test steps found");
        return [];
    }
    // The steps can come in out of order but are sortable by timestamp
    const sortedSteps = [...steps].sort((a, b) => {
        const tsCompare = a.timestamp.localeCompare(b.timestamp);
        if (tsCompare === 0) {
            return toEventOrder(a) - toEventOrder(b);
        }
        return tsCompare;
    });
    const testStartEvents = sortedSteps.filter(a => a.event === "test:start");
    const tests = resultTests.map(result => {
        const step = testStartEvents.find(e => e.test.join(",") === result.title.join(","));
        return {
            title: result.title[result.title.length - 1],
            path: result.title,
            result: mapStateToResult(result.state),
            relativePath: spec.relative,
            relativeStartTime: step ? toRelativeTime(step.timestamp, firstTimestamp) : 0,
            steps: [],
        };
    });
    debug("Found %d tests", tests.length);
    debug("%O", tests.map(t => t.title));
    const stepStack = [];
    const skippedStepIds = [];
    // steps are grouped by `chainerId` and then assigned a parent here by
    // tracking the most recent groupId
    let activeGroup;
    let currentTest;
    for (let i = 0; i < sortedSteps.length; i++) {
        const step = sortedSteps[i];
        let testForStep = tests.find(t => t.title === step.test[step.test.length - 1]);
        if (currentTest !== testForStep) {
            activeGroup = undefined;
        }
        currentTest = testForStep;
        assertCurrentTest(currentTest, step);
        debug("Processing %s event: %o", step.event, step);
        switch (step.event) {
            case "step:enqueue":
                // ignore for now ...
                break;
            case "step:start":
                let parentId;
                if (shouldSkipStep(step, skippedStepIds, debug)) {
                    if ((_a = step.command) === null || _a === void 0 ? void 0 : _a.id) {
                        skippedStepIds.push(step.command.id);
                    }
                    if ((_b = step.command) === null || _b === void 0 ? void 0 : _b.groupId) {
                        skippedStepIds.push(step.command.groupId);
                    }
                    break;
                }
                if (activeGroup && activeGroup.groupId === ((_c = step.command) === null || _c === void 0 ? void 0 : _c.groupId)) {
                    parentId = activeGroup.parentId;
                }
                else if ((_d = step.command) === null || _d === void 0 ? void 0 : _d.groupId) {
                    activeGroup = { groupId: step.command.groupId, parentId: step.command.id };
                }
                // Simplify args to avoid sending large objects in metadata that we
                // won't render in the UI anyway
                const args = ((_f = (_e = step.command) === null || _e === void 0 ? void 0 : _e.args) === null || _f === void 0 ? void 0 : _f.map(a => (a && typeof a === "object" ? {} : a))) || [];
                const testStep = {
                    id: step.command.id,
                    parentId,
                    name: step.command.name,
                    args: args,
                    commandId: step.command.commandId,
                    relativeStartTime: toRelativeTime(step.timestamp, firstTimestamp) - currentTest.relativeStartTime,
                    category: step.category || "other",
                    hook: step.hook,
                };
                // If this assertion has an associated commandId, find that step by
                // command and add this command to its assertIds array
                if (step.command.commandId) {
                    const commandStep = currentTest.steps.find(s => s.id === step.command.commandId);
                    if (commandStep) {
                        commandStep.assertIds = (commandStep === null || commandStep === void 0 ? void 0 : commandStep.assertIds) || [];
                        commandStep.assertIds.push(testStep.id);
                    }
                }
                currentTest.steps.push(testStep);
                stepStack.push({ event: step, step: testStep });
                break;
            case "step:end":
                assertCurrentTest(currentTest, step);
                const isAssert = step.command.name === "assert";
                const lastStep = stepStack.find(a => a.step.id === step.command.id && a.event.test.toString() === step.test.toString());
                if (!lastStep && skippedStepIds.includes((_g = step.command) === null || _g === void 0 ? void 0 : _g.id)) {
                    // ignore step:ends for skipped steps
                    break;
                }
                // TODO [ryanjduffy]: Skipping handling after each events for now
                if (step.test[0] === constants_1.AFTER_EACH_HOOK) {
                    debug("After each hooks are not currently supported");
                    continue;
                }
                assertMatchingStep(step, lastStep === null || lastStep === void 0 ? void 0 : lastStep.event);
                // asserts can change the args if the message changes
                if (isAssert && step.command) {
                    lastStep.step.args = step.command.args;
                }
                const currentTestStep = lastStep.step;
                const relativeEndTime = toRelativeTime(step.timestamp, firstTimestamp) - currentTest.relativeStartTime;
                currentTestStep.duration = Math.max(0, relativeEndTime - currentTestStep.relativeStartTime);
                // Always set the error so that a successful retry will clear a previous error
                currentTestStep.error = step.error;
                break;
            case "test:end":
                currentTest.duration =
                    toRelativeTime(step.timestamp, firstTimestamp) - currentTest.relativeStartTime;
                break;
        }
    }
    return tests;
}
exports.groupStepsByTest = groupStepsByTest;
//# sourceMappingURL=steps.js.map
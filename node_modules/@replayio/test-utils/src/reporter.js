"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReporterError = void 0;
const replay_1 = require("@replayio/replay");
const metadata_1 = require("@replayio/replay/metadata");
const fs_1 = require("fs");
const debug_1 = __importDefault(require("debug"));
const uuid = require("uuid");
const metadata_2 = require("./metadata");
const metrics_1 = require("./metrics");
const debug = (0, debug_1.default)("replay:test-utils:reporter");
function parseRuntime(runtime) {
    return ["chromium", "gecko", "node"].find(r => runtime === null || runtime === void 0 ? void 0 : runtime.includes(r));
}
class ReporterError extends Error {
    constructor(testId, message) {
        super();
        Object.defineProperty(this, "testId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.message = message;
        this.name = "ReporterError";
        this.testId = testId;
    }
    valueOf() {
        return {
            name: this.name,
            message: this.message,
            test: this.testId,
        };
    }
}
exports.ReporterError = ReporterError;
class ReplayReporter {
    constructor(runner) {
        Object.defineProperty(this, "baseId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: uuid.validate(process.env.RECORD_REPLAY_METADATA_TEST_RUN_ID || process.env.RECORD_REPLAY_TEST_RUN_ID || "")
                ? process.env.RECORD_REPLAY_METADATA_TEST_RUN_ID || process.env.RECORD_REPLAY_TEST_RUN_ID
                : uuid.v4()
        });
        Object.defineProperty(this, "baseMetadata", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "runTitle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "startTimes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "runner", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "errors", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        this.runner = runner;
    }
    getTestId(testId) {
        if (!testId) {
            return this.baseId;
        }
        return `${this.baseId}-${testId}`;
    }
    parseConfig(config = {}, metadataKey) {
        // always favor environment variables over config so the config can be
        // overwritten at runtime
        this.runTitle = process.env.RECORD_REPLAY_TEST_RUN_TITLE || config.runTitle;
        // RECORD_REPLAY_METADATA is our "standard" metadata environment variable.
        // We suppress it for the browser process so we can use
        // RECORD_REPLAY_METADATA_FILE but can still use the metadata here which
        // runs in the test runner process. However, test runners may have a
        // convention for reporter-specific environment configuration which should
        // supersede this.
        if (metadataKey && process.env[metadataKey] && process.env.RECORD_REPLAY_METADATA) {
            console.warn(`Cannot set metadata via both RECORD_REPLAY_METADATA and ${metadataKey}. Using ${metadataKey}.`);
        }
        const baseMetadata = (metadataKey && process.env[metadataKey]) ||
            process.env.RECORD_REPLAY_METADATA ||
            config.metadata ||
            null;
        if (baseMetadata) {
            // Since we support either a string in an environment variable or an
            // object in the cfg, we need to parse out the string value. Technically,
            // you could use a string in the config file too but that'd be unexpected.
            // Nonetheless, it'll be handled correctly here if you're into that sort
            // of thing.
            if (typeof baseMetadata === "string") {
                try {
                    this.baseMetadata = JSON.parse(baseMetadata);
                }
                catch (_a) {
                    console.warn("Failed to parse Replay metadata");
                }
            }
            else {
                this.baseMetadata = baseMetadata;
            }
        }
    }
    addError(err) {
        if (err) {
            this.errors.push(err);
        }
    }
    setDiagnosticMetadata(metadata) {
        this.baseMetadata = Object.assign(Object.assign({}, this.baseMetadata), { "x-replay-diagnostics": metadata });
    }
    onTestSuiteBegin(config, metadataKey) {
        this.parseConfig(config, metadataKey);
        debug("onTestSuiteBegin: Reporter Configuration: %o", {
            baseId: this.baseId,
            runTitle: this.runTitle,
            runner: this.runner,
            baseMetadata: this.baseMetadata,
        });
    }
    onTestBegin(testId, metadataFilePath = (0, metadata_2.getMetadataFilePath)("REPLAY_TEST", 0)) {
        this.errors = [];
        this.startTimes[this.getTestId(testId)] = Date.now();
        const metadata = Object.assign(Object.assign({}, (this.baseMetadata || {})), { "x-replay-test": {
                id: this.getTestId(testId),
            } });
        debug("onTestBegin: Writing metadata to %s: %o", metadataFilePath, metadata);
        (0, fs_1.writeFileSync)(metadataFilePath, JSON.stringify(metadata, undefined, 2), {});
    }
    onTestEnd(tests, replayTitle, extraMetadata) {
        var _a;
        // if we bailed building test metadata because of a crash or because no
        // tests ran, we can bail here too
        if (tests.length === 0) {
            debug("onTestEnd: No tests found");
            return;
        }
        const filter = `function($v) { $v.metadata.\`x-replay-test\`.id in ${JSON.stringify(tests.map(test => this.getTestId(test.id)))} and $not($exists($v.metadata.test)) }`;
        const recs = (0, replay_1.listAllRecordings)({
            filter,
        });
        debug("onTestEnd: Found %d recs with filter %s", recs.length, filter);
        const test = tests[0];
        const results = tests.reduce((acc, t) => (acc.includes(t.result) ? acc : [...acc, t.result]), []);
        const result = results.length === 1
            ? results[0]
            : results.includes("failed")
                ? "failed"
                : results.includes("timedOut")
                    ? "timedOut"
                    : "passed";
        let recordingId;
        let runtime;
        if (recs.length > 0) {
            recordingId = recs[0].id;
            runtime = recs[0].runtime;
            debug("onTestEnd: Adding test metadata to %s", recordingId);
            debug("onTestEnd: Includes %s errors", this.errors.length);
            recs.forEach(rec => (0, metadata_1.add)(rec.id, Object.assign(Object.assign(Object.assign({ title: replayTitle || test.title }, extraMetadata), metadata_1.test.init({
                title: replayTitle || test.title,
                result,
                path: test.path,
                runner: this.runner,
                run: {
                    id: this.baseId,
                    title: this.runTitle,
                },
                file: test.relativePath,
                tests: tests,
            })), (this.errors.length
                ? {
                    "x-replay-errors": {
                        reporter: this.errors,
                    },
                }
                : null))));
        }
        const startTime = this.startTimes[this.getTestId(test.id)];
        if (startTime) {
            (0, metrics_1.pingTestMetrics)(recordingId, this.baseId, {
                id: test.id || test.relativePath,
                duration: Date.now() - startTime,
                recorded: !!recordingId,
                runtime: parseRuntime(runtime),
                runner: (_a = this.runner) === null || _a === void 0 ? void 0 : _a.name,
                result: result,
            });
        }
    }
}
exports.default = ReplayReporter;
//# sourceMappingURL=reporter.js.map
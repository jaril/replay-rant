"use strict";
/* Copyright 2020 Record Replay Inc. */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.uploadSourceMaps = void 0;
// "URL" is available as a global, but Typescript doesn't have the types
// for it. Importing it from the module does have types though.
const url_1 = require("url");
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const util_1 = __importDefault(require("util"));
const crypto_1 = __importDefault(require("crypto"));
const assert_1 = __importDefault(require("assert"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const debug_1 = __importDefault(require("debug"));
const glob_1 = __importDefault(require("glob"));
const string_prototype_matchall_1 = __importDefault(require("string.prototype.matchall"));
const globPromisified = util_1.default.promisify(glob_1.default);
const debug = debug_1.default("recordreplay:sourcemap-upload");
async function uploadSourceMaps(opts) {
    var _a, _b, _c, _d;
    assert_1.default(Array.isArray(opts.filepaths)
        ? opts.filepaths.every((p) => typeof p === "string")
        : typeof opts.filepaths === "string", "'filepaths' must be a string or array of strings");
    assert_1.default(typeof opts.group === "string", "'group' must be a string");
    assert_1.default(typeof opts.key === "string" || opts.key === undefined, "'key' must be a string or undefined");
    assert_1.default(typeof opts.dryRun === "boolean" || opts.dryRun === undefined, "'dryRun' must be a string or undefined");
    assert_1.default((Array.isArray(opts.extensions) &&
        opts.extensions.every((ext) => typeof ext === "string")) ||
        opts.extensions === undefined, "'extensions' must be an array of strings or undefined");
    assert_1.default(!opts.extensions || opts.extensions.length > 0, "'extensions' must not be empty");
    assert_1.default((_b = (_a = opts.extensions) === null || _a === void 0 ? void 0 : _a.every((ext) => !glob_1.default.hasMagic(ext))) !== null && _b !== void 0 ? _b : true, "'extensions' entries may not contain special glob chars");
    assert_1.default((_d = (_c = opts.extensions) === null || _c === void 0 ? void 0 : _c.every((ext) => ext.startsWith("."))) !== null && _d !== void 0 ? _d : true, "'extensions' entries must start with '.'");
    assert_1.default((Array.isArray(opts.ignore) &&
        opts.ignore.every((pattern) => typeof pattern === "string")) ||
        opts.ignore === undefined, "'ignore' must be an array of strings or undefined");
    assert_1.default(typeof opts.root === "string" || opts.root === undefined, "'root' must be a string or undefined");
    const apiKey = opts.key || process.env.RECORD_REPLAY_API_KEY || null;
    assert_1.default(apiKey, "'key' must contain a key, or the RECORD_REPLAY_API_KEY must be set.");
    assert_1.default(typeof opts.log === "function" || opts.log === undefined, "'log' must be a function or undefined");
    const apiServer = opts.server ||
        process.env.RECORD_REPLAY_API_SERVER ||
        "https://api.replay.io";
    assert_1.default(typeof apiServer === "string" || "'apiServer' must be a string");
    const cwd = process.cwd();
    return processSourceMaps({
        cwd,
        filepaths: Array.isArray(opts.filepaths)
            ? opts.filepaths
            : [opts.filepaths],
        groupName: opts.group,
        apiKey,
        dryRun: !!opts.dryRun,
        extensions: opts.extensions || [".js", ".map"],
        ignorePatterns: opts.ignore || [],
        rootPath: path_1.default.resolve(cwd, opts.root || ""),
        log: opts.log || (() => undefined),
        apiServer,
    });
}
exports.uploadSourceMaps = uploadSourceMaps;
async function processSourceMaps(opts) {
    var _a;
    debug("resolved options: %O", {
        ...opts,
        // In the interest of not logging the API key in debug output, just log its size.
        apiKey: (_a = opts.apiKey) === null || _a === void 0 ? void 0 : _a.length,
    });
    const sourceMaps = await findAndResolveMaps(opts);
    const { groupName, apiKey, dryRun, rootPath, log } = opts;
    const mapsToUpload = [];
    for (const map of sourceMaps) {
        const relativePath = path_1.default.relative(rootPath, map.absPath);
        if (map.generatedFiles.size === 1) {
            const [generatedFile] = map.generatedFiles;
            mapsToUpload.push({
                absPath: map.absPath,
                relativePath,
                content: map.fileContent,
                generatedFileHash: generatedFile.sha,
            });
            debug("Resolved generated source %s for %s", generatedFile.absPath, map.absPath);
            log("verbose", `Linked ${relativePath} to ${generatedFile.absPath}`);
        }
        else if (map.generatedFiles.size === 0) {
            debug("Failed to resolve generated source for %s", map.absPath);
            log("verbose", `Skipped ${relativePath} because no generated files for it could be found`);
        }
        else {
            debug("Failed to resolve generated source for %s, matched multiple sources: %O", map.absPath, Array.from(map.generatedFiles, (genFile) => genFile.absPath));
            log("verbose", `Skipped ${relativePath} because multiple generated files were found for it`);
        }
    }
    for (const mapToUpload of mapsToUpload) {
        const { relativePath, absPath } = mapToUpload;
        debug("Uploading %s", absPath);
        log("normal", `Uploading ${relativePath}`);
        if (!dryRun) {
            await uploadSourcemapToAPI(groupName, apiKey, mapToUpload, opts.apiServer);
        }
    }
    debug("Done");
    log("normal", `Done! Uploaded ${mapsToUpload.length} sourcemaps${dryRun ? " (DRY RUN)" : ""}`);
}
async function sendUploadPUT(opts) {
    return node_fetch_1.default(`${opts.apiServer}/v1/sourcemap-upload`, {
        method: "PUT",
        headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${opts.apiKey}`,
            "X-Replay-SourceMap-Group": opts.groupName,
            "X-Replay-SourceMap-Filename": opts.map.relativePath,
            "X-Replay-SourceMap-ContentHash": `sha256:${opts.map.generatedFileHash}`,
        },
        body: opts.map.content,
    });
}
async function sendUploadPUTWithRetries(opts) {
    for (let i = 0; i < 5; i++) {
        try {
            return await sendUploadPUT(opts);
        }
        catch (err) {
            debug("Sourcemap upload attempt %d failed for %s, got %O", i, opts.map.absPath, err);
        }
    }
    return sendUploadPUT(opts);
}
async function uploadSourcemapToAPI(groupName, apiKey, map, apiServer) {
    let response;
    try {
        response = await sendUploadPUTWithRetries({
            groupName,
            apiKey,
            map,
            apiServer,
        });
    }
    catch (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    err) {
        debug("Failure uploading sourcemap %s, got %O", map.absPath, err);
        throw new Error(`Unexpected error uploading sourcemap: ${err}`);
    }
    let obj;
    try {
        const text = await response.text();
        try {
            obj = JSON.parse(text);
        }
        catch (err) {
            debug("Failure parsing sourcemap upload response JSON for %s, got body %s", map.absPath, text.slice(0, 200) + (text.length > 200 ? "..." : ""));
            throw err;
        }
        if (!obj || typeof obj !== "object") {
            throw new Error("JSON response was not an object");
        }
    }
    catch (err) {
        debug("Failure processing sourcemap upload response for %s, got %O", map.absPath, err);
        throw new Error("Unexpected error processing upload response");
    }
    if (response.status !== 200) {
        debug("Failure uploading sourcemap for %s, got %O", map.absPath, obj);
        throw new Error(typeof obj.error === "string" ? obj.error : "Unknown upload error");
    }
}
async function findAndResolveMaps(opts) {
    var _a;
    const { cwd, filepaths, extensions, ignorePatterns } = opts;
    const seenFiles = new Set();
    const generatedFiles = new Map();
    const sourceMaps = new Map();
    for (const fileArg of filepaths) {
        const absFileArg = path_1.default.resolve(cwd, fileArg);
        debug("processing argument: %s", absFileArg);
        for (const absPath of await listAllFiles(absFileArg, ignorePatterns, extensions)) {
            if (seenFiles.has(absPath)) {
                continue;
            }
            seenFiles.add(absPath);
            debug("processing filepath: %s", absPath);
            const fileContent = await fs_1.default.promises.readFile(absPath, "utf8");
            let map;
            try {
                map = JSON.parse(fileContent);
            }
            catch (_b) {
                // No-op
            }
            debug("read filepath: %s", absPath);
            const fileURL = url_1.pathToFileURL(absPath).toString();
            if (map !== undefined) {
                if (!map || typeof map !== "object") {
                    debug("JSON is not an object, skipping %s", absPath);
                    continue;
                }
                if (map.version !== 3 || typeof map.mappings !== "string") {
                    debug("JSON is not a sourcemap, skipping %s", absPath);
                    continue;
                }
                if (map.file != null && typeof map.file !== "string") {
                    debug("Sourcemap has an invalid 'file' key, skipping %s", absPath);
                    continue;
                }
                let generatedFile;
                try {
                    generatedFile = map.file ? new url_1.URL(map.file, fileURL) : undefined;
                }
                catch (_c) {
                    debug("Failed to resolve 'file', ignoring value in %s", absPath);
                }
                sourceMaps.set(fileURL, {
                    fileURL,
                    absPath,
                    fileContent,
                    generatedFile: generatedFile === null || generatedFile === void 0 ? void 0 : generatedFile.toString(),
                    generatedFiles: new Set(),
                });
            }
            else {
                debug("hashing filepath: %s", absPath);
                const hasher = crypto_1.default.createHash("SHA256");
                hasher.update(fileContent);
                const sha = hasher.digest("hex");
                // Files could have strings or comments that happen to container the sourcemap
                // comment text and such, so we need to explictly grab the value in the
                //trailing comments.
                const match = fileContent.match(/(?:\/\*(?:[^*]|\*[^/])*\*\/|\/\/.*?(?:\r?\n|$)|\r?\n)*$/);
                assert_1.default(match);
                const [trailingComments] = match;
                const matches = string_prototype_matchall_1.default(trailingComments, /\/\*(?:[@#] *sourceMappingURL=(.*)\s*|[\s\S]*?)\*\/|\/\/(?:[@#] *sourceMappingURL=(.*)|.*?)(?:\r?\n|$)|\r?\n/g);
                debug("hashed filepath: %s", absPath);
                const url = Array.from(matches, (match) => { var _a; return (_a = (match[1] || match[2])) === null || _a === void 0 ? void 0 : _a.trim(); })
                    .filter((url) => typeof url === "string")
                    .pop();
                let mapURL;
                try {
                    mapURL = url ? new url_1.URL(url, fileURL) : undefined;
                }
                catch (_d) {
                    debug("Failed to resolve sourceMappingURL, ignoring value in %s", absPath);
                }
                if (mapURL && mapURL.protocol !== "file:") {
                    debug("Generated file had non-file: sourceMappingURL, ignoring value in %s", absPath);
                    mapURL = undefined;
                }
                generatedFiles.set(fileURL, {
                    fileURL,
                    absPath,
                    sha,
                    mapURL: mapURL === null || mapURL === void 0 ? void 0 : mapURL.toString(),
                });
            }
        }
    }
    debug("done processing arguments");
    // Follow 'sourceMappingURL' references to find sourcemap for generated files.
    for (const generatedFile of generatedFiles.values()) {
        if (generatedFile.mapURL) {
            (_a = sourceMaps.get(generatedFile.mapURL)) === null || _a === void 0 ? void 0 : _a.generatedFiles.add(generatedFile);
        }
    }
    // Follow 'file' references to find generated sources for sourcemap.
    for (const map of sourceMaps.values()) {
        if (map.generatedFile) {
            const generatedFile = generatedFiles.get(map.generatedFile);
            if (generatedFile) {
                map.generatedFiles.add(generatedFile);
            }
        }
    }
    return Array.from(sourceMaps.values());
}
async function listAllFiles(absPath, ignorePatterns, extensions) {
    const stat = await fs_1.default.promises.stat(absPath);
    if (stat.isFile()) {
        return [absPath];
    }
    else if (stat.isDirectory()) {
        assert_1.default(extensions.every((ext) => !glob_1.default.hasMagic(ext)));
        return globPromisified(`**/*+(${extensions.join("|")})`, {
            cwd: absPath,
            ignore: ignorePatterns,
            absolute: true,
        });
    }
    return [];
}
